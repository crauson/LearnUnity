//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.42000
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Security.Cryptography;
using System.Text;
using System.IO;

namespace CrausonUtility
{
	public class AESUtil
	{

		public  const string gDefaultKey = "1a2b3c4d5e6f7g8h9i0j1k2l3m4n5o6p";

		public AESUtil ()
		{
		}
		/*
		 * 加密字符串
		 * 
		 * @EncryptString 待加密字符串
		 * @EncryptKey 加密秘钥
		 * */
		public static string AESEncrypt (string EncryptString, string EncryptKey)
		{
			byte[] keyArray = UTF8Encoding.UTF8.GetBytes (EncryptKey);  
			byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes (EncryptString);  
			RijndaelManaged rDel = new RijndaelManaged ();  
			rDel.Key = keyArray;  
			rDel.Mode = CipherMode.ECB;  
			rDel.Padding = PaddingMode.PKCS7;  
			ICryptoTransform cTransform = rDel.CreateEncryptor ();  
			byte[] resultArray = cTransform.TransformFinalBlock (toEncryptArray, 0, toEncryptArray.Length);  
			return Convert.ToBase64String (resultArray, 0, resultArray.Length);  
		}


		/*
		 * 加密字节数组
		 * */
		public static byte[] AESEncrypt (byte[] EncryptByte, string EncryptKey)
		{
			if (EncryptByte.Length == 0) {
				throw (new Exception ("明文不得为空"));
			}
			if (string.IsNullOrEmpty (EncryptKey)) {
				throw (new Exception ("密钥不得为空"));
			}
			byte[] m_strEncrypt;
			byte[] m_btIV = Convert.FromBase64String ("Rkb4jvUy/ye7Cd7k89QQgQ==");
			byte[] m_salt = Convert.FromBase64String ("gsf4jvkyhye5/d7k8OrLgM==");
			Rijndael m_AESProvider = Rijndael.Create ();
			try {
				MemoryStream m_stream = new MemoryStream ();
				PasswordDeriveBytes pdb = new PasswordDeriveBytes (EncryptKey, m_salt);
				ICryptoTransform transform = m_AESProvider.CreateEncryptor (pdb.GetBytes (32), m_btIV);
				CryptoStream m_csstream = new CryptoStream (m_stream, transform, CryptoStreamMode.Write);
				m_csstream.Write (EncryptByte, 0, EncryptByte.Length);
				m_csstream.FlushFinalBlock ();
				m_strEncrypt = m_stream.ToArray ();
				m_stream.Close ();
				m_stream.Dispose ();
				m_csstream.Close ();
				m_csstream.Dispose ();
			} catch (IOException ex) {
				throw ex;
			} catch (CryptographicException ex) {
				throw ex;
			} catch (ArgumentException ex) {
				throw ex;
			} catch (Exception ex) {
				throw ex;
			} finally {
				m_AESProvider.Clear ();
			}
			return m_strEncrypt;
		}

		public static string AESDecrypt (string DecryptString, string DecryptKey)
		{
			byte[] keyArray = UTF8Encoding.UTF8.GetBytes (DecryptKey);  
			byte[] toEncryptArray = Convert.FromBase64String (DecryptString);  
			RijndaelManaged rDel = new RijndaelManaged ();  
			rDel.Key = keyArray;  
			rDel.Mode = CipherMode.ECB;  
			rDel.Padding = PaddingMode.PKCS7;  
			ICryptoTransform cTransform = rDel.CreateDecryptor ();  
			byte[] resultArray = cTransform.TransformFinalBlock (toEncryptArray, 0, toEncryptArray.Length);  
			 
			return UTF8Encoding.UTF8.GetString (resultArray);  
		}

		public static byte[] AESDecrypt (byte[] DecryptByte, string DecryptKey)
		{
			if (DecryptByte.Length == 0) {
				throw (new Exception ("密文不得为空"));
			}
			if (string.IsNullOrEmpty (DecryptKey)) {
				throw (new Exception ("密钥不得为空"));
			}
			byte[] m_strDecrypt;
			byte[] m_btIV = Convert.FromBase64String ("Rkb4jvUy/ye7Cd7k89QQgQ==");
			byte[] m_salt = Convert.FromBase64String ("gsf4jvkyhye5/d7k8OrLgM==");
			Rijndael m_AESProvider = Rijndael.Create ();
			try {
				MemoryStream m_stream = new MemoryStream ();
				PasswordDeriveBytes pdb = new PasswordDeriveBytes (DecryptKey, m_salt);
				ICryptoTransform transform = m_AESProvider.CreateDecryptor (pdb.GetBytes (32), m_btIV);
				CryptoStream m_csstream = new CryptoStream (m_stream, transform, CryptoStreamMode.Write);
				m_csstream.Write (DecryptByte, 0, DecryptByte.Length);
				m_csstream.FlushFinalBlock ();
				m_strDecrypt = m_stream.ToArray ();
				m_stream.Close ();
				m_stream.Dispose ();
				m_csstream.Close ();
				m_csstream.Dispose ();
			} catch (IOException ex) {
				throw ex;
			} catch (CryptographicException ex) {
				throw ex;
			} catch (ArgumentException ex) {
				throw ex;
			} catch (Exception ex) {
				throw ex;
			} finally {
				m_AESProvider.Clear ();
			}
			return m_strDecrypt;
		}
	}
}

